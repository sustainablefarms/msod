# jsodm with spatially correlated latent variable values, exponential covariance function
model{

  # community priors for occupancy covariates
  for(m in 1:Vocc) {
    mu.u.b[m] ~ dnorm(0, 0.01)T(-10,10)
    tau.u.b[m] <- pow(sigma.u.b[m], -2)
    sigma.u.b[m] ~ dunif(0, 10)
  }

  # community priors for detection covariates
  for(m in 1:Vobs) {
    mu.v.b[m] ~ dnorm(0, 0.01)T(-10,10)
    tau.v.b[m] <- pow(sigma.v.b[m], -2)
    sigma.v.b[m] ~ dunif(0, 10)
  }

  # Latent variables (from boral's R/makejagsboralmodel.R)
  for(k in 1:nlv) { LV[1:J,k] ~ dmnorm(zeroLV,invSigmaLV) } 
  for(k1 in 1:J) { 
    for(k2 in 1:J) { 
      SigmaLV[k1,k2] <- exp(-spatdistmat[k1,k2]/lv.covspatscale[1]) * exp(-timedistmat[k1,k2]/lv.covtimescale[1]) 
    } 
  } 
  invSigmaLV <- inverse(SigmaLV) 
  lv.covspatscale[1] ~ dnorm(0,0.1)I(0,)
  lv.covtimescale[1] ~ dnorm(0,0.1)I(0,)



  # Latent variable coefficients with constraints
  # diagonal elements positive, upper diagonal 0
  for(l in 1:(nlv-1)){
        for(l2 in (l+1):nlv){
             lv.coef[l,l2] <- 0
        }
  }

   # Sign constraints on diagonal elements
   for(l in 1:nlv) {
         lv.coef[l,l]  ~ dunif(0,1) 
   }

  # lower diagonal free
  for(l in 2:nlv){
        for(l2 in 1:(l-1)){
             lv.coef[l,l2] ~ dunif(-1,1)
        }
  }

  # other elements free
  for(i in (nlv+1):n) {
        for(l in 1:nlv){
              lv.coef[i,l] ~ dunif(-1,1)
        }
  }

  # loop over all species
  for (i in 1:(n)) {


    # random effects for occupancy
    for(m in 1:Vocc) {
      u.b[i, m] ~ dnorm(mu.u.b[m], tau.u.b[m])T(-10,10)
    }

    # random effects for detection
    for(m in 1:Vobs) {
      v.b[i, m] ~ dnorm(mu.v.b[m], tau.v.b[m])T(-10,10)
    }
    
    # loop over all sites to give occupancy
    for (j in 1:J) {

      # probit model for occupancy
      eta[j,i] <-  inprod(u.b[i, ], Xocc[j, ]) + inprod(lv.coef[i,],LV[j, ])
      # draw from normal, constrain variance to 1
      u[j,i] ~ dnorm(eta[j,i],1/(1-sum(lv.coef[i,1:nlv]^2))) 
      z[j,i] <- step(u[j,i])
   }
   
   # apply occupancy probabilities to detection
   for (l in 1:Vvisits) {
      # logistic model for detection
      logit(p[l,i]) <-   inprod(v.b[i, ], Xobs[l, ])
      mu.p[l,i] <- p[l,i]*z[ModelSite[l],i]
      y[l,i] ~ dbern(mu.p[l,i])
   }
  }

}

